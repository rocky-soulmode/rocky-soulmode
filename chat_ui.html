<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" >
  <meta name="viewport" content="width=device-width,initial-scale=1" >
  <title>Rocky Soulmode ‚Äî Chat Memory (Polished)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* ---------- Theme & layout (kept your polished design, cleaned) ---------- */
    :root{
      --bg: #f6f9fc;
      --panel: #ffffff;
      --muted: #6b7280;
      --accent: #0ea5a0;
      --accent-2: #ffb020;
      --glass: rgba(2,6,23,0.04);
      --card: #ffffff;
      --danger:#ef4444;
      --shadow: 0 8px 24px rgba(2,6,23,0.06);
      --radius: 12px;
      --max-width: 1200px;
      --font: Inter, system-ui, "Segoe UI", Arial, sans-serif;
    }
    * { box-sizing: border-box; }
    html,body { height: 100%; margin: 0; font-family: var(--font); background: linear-gradient(180deg,#f3f7fb,#eef6fb); color: #041826; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    a { color: inherit; text-decoration: none; }
    button { font: inherit; }

    .app { display:flex; min-height:100vh; }

    /* Sidebar */
    .sidebar {
      width:92px;
      background: linear-gradient(180deg,#fff,#f8fbff);
      border-right: 1px solid rgba(2,6,23,0.04);
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:12px;
      gap:14px;
      position:relative;
    }
    .logo {
      width:56px; height:56px; border-radius:12px;
      background: linear-gradient(135deg,var(--accent),var(--accent-2));
      display:flex; align-items:center; justify-content:center; color:#012; font-weight:700; box-shadow:var(--shadow);
    }
    .navBtn {
      width:56px; height:56px; border-radius:10px; background:transparent; border:0; cursor:pointer;
      display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:18px;
    }
    .navBtn.active { background:var(--glass); color:var(--accent); }
    .bottomArea { margin-top:auto; }

    /* Main area */
    .main { flex:1; display:flex; flex-direction:column; }
    header { display:flex; align-items:center; justify-content:space-between; padding:14px 20px; border-bottom:1px solid rgba(2,6,23,0.03); background:transparent; }
    .header-left { display:flex; gap:14px; align-items:center; }
    .title { font-weight:700; font-size:16px; }
    .server-status { font-size:13px; color:var(--muted); }
    .header-actions { display:flex; gap:10px; align-items:center; }

    .btn { padding:8px 12px; border-radius:10px; border:0; cursor:pointer; font-weight:600; }
    .btn-primary { background:var(--accent); color:#022; box-shadow:0 6px 18px rgba(14,165,160,0.12); }
    .btn-ghost { background:transparent; border:1px solid rgba(2,6,23,0.06); color:var(--muted); }

    .layout { display:flex; gap:18px; padding:18px; max-width:var(--max-width); margin:16px auto; width:100%; box-sizing:border-box; }
    .panel { background:var(--panel); border-radius:var(--radius); box-shadow:var(--shadow); padding:14px; border:1px solid rgba(2,6,23,0.03); }

    /* Chat */
    .chatCol { flex:1; display:flex; flex-direction:column; height:74vh; min-width: 420px; }
    #msgs { flex:1; overflow:auto; padding:16px; display:flex; flex-direction:column; gap:10px; border-radius:10px; background:linear-gradient(180deg,#fbfeff,#f6fbff); }
    .msg { max-width:78%; padding:12px; border-radius:10px; line-height:1.4; word-break:break-word; }
    .user { align-self:flex-end; background:linear-gradient(90deg, rgba(14,165,160,0.12), rgba(14,165,160,0.03)); color:#053633; }
    .assistant { align-self:flex-start; background:linear-gradient(90deg, rgba(255,176,32,0.08), rgba(255,176,32,0.02)); color:#4b2f00; }

    .composer { display:flex; gap:12px; align-items:flex-end; margin-top:12px; }
    textarea { flex:1; min-height:52px; max-height:260px; padding:12px; border-radius:10px; border:1px solid rgba(2,6,23,0.06); resize:vertical; font-size:14px; font-family:var(--font); }

    /* right column / memories */
    .sideCol { width:380px; display:flex; flex-direction:column; gap:12px; }
    .searchRow { display:flex; gap:8px; }
    input[type="text"], input[type="email"], textarea { padding:10px; border-radius:10px; border:1px solid rgba(2,6,23,0.06); width:100%; font-size:14px; }
    .memList { max-height:46vh; overflow:auto; border-radius:8px; padding:6px; display:flex; flex-direction:column; gap:8px; }
    .memItem { display:flex; justify-content:space-between; gap:8px; padding:10px; border-radius:8px; border:1px solid rgba(2,6,23,0.03); background:linear-gradient(180deg,#fff,#fbfdff); align-items:flex-start; }
    .memKey { font-weight:600; color:#06222b; }
    .memVal { color:var(--muted); font-size:13px; white-space:pre-wrap; max-height:72px; overflow:hidden; }
    .controls { display:flex; gap:6px; }
    .pager { display:flex; gap:8px; align-items:center; justify-content:center; padding-top:8px; }
    .badge { background:#eef6f5; color:#065; padding:6px 10px; border-radius:999px; font-weight:600; }

    /* modal */
    .modal { position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(2,6,23,0.45); display:none; align-items:center; justify-content:center; z-index:60; }
    .modal.show { display:flex; }
    .modalCard { width:92%; max-width:980px; background:var(--panel); border-radius:12px; padding:18px; box-shadow:0 20px 60px rgba(2,6,23,0.3); }
    .row { display:flex; gap:8px; align-items:center; }
    .small { font-size:13px; color:var(--muted); }
    .switch { display:inline-flex; align-items:center; gap:8px; }
    .sideNavTitle { writing-mode:vertical-rl; text-orientation:upright; color:var(--muted); font-size:12px; }

    /* responsive */
    @media (max-width:1000px){ .layout{padding:12px;width:95%} .sideCol{display:none} .sidebar{display:flex} .chatCol{min-width:unset} }
    .hidden { display:none !important; }
  </style>
</head>
<body>

<!-- Keep essential safe hidden inputs (used by JS defaults) -->
<input type="hidden" id="pageSize" value="8">
<input type="hidden" id="valuePageSize" value="1200">
<input type="hidden" id="autoSync" value="true">
<input type="hidden" id="showRaw">

<div class="app" role="application" aria-label="Rocky Soulmode Chat Memory App">
  <!-- Sidebar -->
  <div class="sidebar" role="navigation" aria-label="Main navigation">
    <div class="logo" title="Rocky Soulmode">RS</div>
    <button class="navBtn active" id="navChat" title="Chat" aria-pressed="true">üí¨</button>
    <button class="navBtn" id="navMemory" title="Memories" aria-pressed="false">üß†</button>
    <button class="navBtn" id="navSettings" title="Settings" aria-pressed="false">‚öôÔ∏è</button>
    <div class="bottomArea">
      <button class="navBtn" id="navExport" title="Export">‚¨áÔ∏è</button>
    </div>
  </div>

  <!-- Main area -->
  <div class="main">
    <header>
      <div class="header-left">
        <div class="title">üíéüî• Rocky Soulmode ‚Äî Chat Memory</div>
        <div class="server-status small" id="srv" aria-live="polite">Server: unknown</div>
      </div>
       <div class="header-actions">
        <input id="email" type="email" placeholder="you@domain.com" aria-label="Account email" >
        <button class="btn btn-ghost" id="login">Login</button>
        <button class="btn btn-ghost" id="logout" style="display:none">Logout</button>
        <!-- Open Settings (modal) removed ‚Äî settings live in side panel now -->
      </div>
    </header>

    <div class="layout" id="mainLayout" role="main">
      <!-- Chat Panel -->
      <h2 id="chat-heading" class="small" style="display:none">Chat</h2>
      <div id="chatPanel" class="chatCol panel" aria-labelledby="chat-heading">
        <div id="msgs" aria-live="polite" aria-atomic="false"></div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
          <div class="small">Account: <strong id="curAccount">(not logged)</strong></div>
          <div>
            <label class="small" for="useLLM">LLM</label>
            <input type="checkbox" id="useLLM" style="margin-left:8px" aria-label="Use LLM">
          </div>
        </div>

        <div class="composer" role="region" aria-label="Message composer">
          <textarea id="messageBox" placeholder="Type a message..." aria-label="Message input"></textarea>
          <div style="display:flex;flex-direction:column;gap:8px;min-width:140px">
            <button class="btn btn-primary" id="send">Send</button>
            <button class="btn btn-ghost" id="clearChat">Clear</button>
            <button class="btn btn-ghost" id="refMemsBtn">Insert last 3 mems</button>
          </div>
        </div>
      </div>
      <!-- Memory Panel -->
      <div id="memoryPanel" class="panel hidden" style="flex:1">
        <div class="panel" style="padding:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Memories</strong>
              <div class="small">Saved facts & notes</div>
            </div>
            <div class="badge" id="memCount">0</div>
          </div>

          <div style="margin-top:10px" class="searchRow">
            <input id="searchQ" type="text" placeholder="Search memories or messages" aria-label="Search memories" >
            <button class="btn btn-ghost" id="searchBtn">Search</button>
          </div>

          <div style="margin-top:10px">
            <div style="display:flex;gap:8px">
              <input id="addKey" type="text" placeholder="key" aria-label="memory key" >
              <button class="btn btn-primary" id="addQuick">Save</button>
            </div>
            <textarea id="addVal" placeholder="value (multi-line)" style="margin-top:8px" aria-label="memory value"></textarea>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="btn btn-ghost" id="syncBtn">Sync local ‚Üí server</button>
              <button class="btn btn-ghost" id="exportBtn">Export</button>
            </div>
          </div>
        </div>

        <div class="panel" style="padding:10px">
          <div class="memList" id="memList" role="list">No memories yet</div>
          <div class="pager" style="margin-top:8px">
            <button class="btn btn-ghost" id="prevPage">Prev</button>
            <div class="small" id="pageInfo">Page 1</div>
            <button class="btn btn-ghost" id="nextPage">Next</button>
          </div>
        </div>
      </div>
      <textarea id="bulkMemories" placeholder='Add multiple memories (JSON object or key:value per line)' style="margin-top:8px"></textarea>
<button class="btn btn-primary" id="bulkAddBtn">Add Multiple</button>

<script>
/*
  Small, safe handler for the "Add Multiple" button placed directly after the button in the DOM.
  This uses only standard DOM APIs (no $ helper) and attempts to call the app's fetch/persistence
  helpers if they are available on window.Rocky. If the app helpers are not yet present, this
  gracefully falls back to localStorage.
*/
(function(){
  const btn = document.getElementById('bulkAddBtn');
  if (!btn) return;
  btn.addEventListener('click', async () => {
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return alert('Login first');
    const textEl = document.getElementById('bulkMemories');
    const text = (textEl && textEl.value || '').trim();
    if (!text) return;

    let mems = [];
    try {
      if (text.trim().startsWith('{')) {
        const obj = JSON.parse(text);
        mems = Object.entries(obj);
      } else {
        mems = text.split('\n').map(l => l.split(':')).filter(a => a.length >= 2);
      }
    } catch (e) {
      return alert('Invalid format ‚Äî use JSON or key:value per line');
    }

    for (const [k, v] of mems) {
      try {
        // Prefer app-provided fetchJSON if available
        if (window.Rocky && typeof window.Rocky.fetchJSON === 'function') {
          await window.Rocky.fetchJSON(`${window.Rocky.API_BASE || ''}/remember`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account, key: k.trim(), value: v.toString().trim() })
          });
        } else {
          // fallback to fetch; note API constant may not be present ‚Äî best-effort
          const API = window.Rocky && window.Rocky.API_BASE ? window.Rocky.API_BASE : (window.API || 'http://127.0.0.1:8000');
          await fetch(`${API}/remember`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account, key: k.trim(), value: v.toString().trim() })
          });
        }
      } catch (err) {
        // fallback: save locally if server/save fails
        try {
          if (window.Rocky && typeof window.Rocky.pushLocalMemory === 'function') {
            window.Rocky.pushLocalMemory(account, k.trim(), v.toString().trim());
          } else {
            const LOCAL_PREFIX = 'rocky_local::';
            const raw = localStorage.getItem(LOCAL_PREFIX + account);
            const p = raw ? JSON.parse(raw) : { memories: {}, threads: {} };
            p.memories = p.memories || {};
            p.memories[k.trim()] = { value: v.toString().trim(), timestamp: (new Date()).toISOString() };
            localStorage.setItem(LOCAL_PREFIX + account, JSON.stringify(p));
          }
        } catch (e2) {
          console.warn('Bulk add local fallback failed', e2);
        }
      }
    }

    if (textEl) textEl.value = '';
    // Prefer in-app appendAssistant or fallback to alert
    if (window.Rocky && typeof window.Rocky.appendAssistant === 'function') {
      window.Rocky.appendAssistant(`‚úÖ Added ${mems.length} memories`);
    } else {
      alert(`‚úÖ Added ${mems.length} memories`);
    }

    // Try to refresh memory list if possible
    try {
      if (window.Rocky && typeof window.Rocky.loadMemories === 'function') {
        await window.Rocky.loadMemories();
      }
    } catch (e) { /* ignore */ }
  });
})();
</script>

      <!-- Settings Panel -->
      <div id="settingsPanel" class="panel hidden" style="flex:1">
        <!-- Moved modal contents here so a separate modal is no longer needed -->
        <h3 id="settings-title">‚öôÔ∏è Settings & Customize ChatGPT</h3>
        <div class="small">Personalize assistant & advanced options (inline)</div>

        <div style="display:flex;gap:18px;margin-top:12px">
          <!-- left: personalization -->
          <div style="flex:1">
            <div style="margin-bottom:8px"><strong>Personality</strong></div>
            <div class="row" style="gap:10px">
              <label class="small">Tone</label>
              <select id="toneSel" style="padding:8px;border-radius:8px">
                <option value="consistent">Consistent</option>
                <option value="friendly">Friendly</option>
                <option value="professional">Professional</option>
                <option value="playful">Playful</option>
              </select>
            </div>

            <div style="margin-top:8px" class="row">
              <label class="small">Style</label>
              <select id="styleSel" style="padding:8px;border-radius:8px">
                <option value="cofounder-high-energy">Cofounder ‚Äî High energy</option>
                <option value="mentor-calm">Mentor ‚Äî Calm</option>
                <option value="technical-expert">Technical expert</option>
              </select>
            </div>

            <div style="margin-top:8px" class="row">
              <label class="small">Signature</label>
              <input id="sigInput" type="text" value="üíéüî•" style="padding:8px;border-radius:8px;flex:1">
            </div>

     <div style="margin-top:12px">
  <label class="small" for="personalitySel">Personality Mode</label>
  <select id="personalitySel" style="padding:8px;border-radius:8px;flex:1">
    <option value="default">üåê Default</option>
    <option value="highest">‚ö° Highest</option>
    <option value="immortal">‚ôæÔ∏è Immortal</option>
    <option value="ghost">üëª Ghost</option>
  </select>
</div>

<script>
  // Save toggle state to backend/local
  async function setPersonalityFlag(flag, value) {
    if (!window.localStorage) return;
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return;
    try {
      if (window.Rocky && typeof window.Rocky.fetchJSON === 'function') {
        await window.Rocky.fetchJSON(`${window.Rocky.API_BASE || ''}/remember`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ account, key: flag, value })
        });
      } else {
        // fallback pushLocalMemory if available
        if (window.Rocky && typeof window.Rocky.pushLocalMemory === 'function') {
          window.Rocky.pushLocalMemory(account, flag, value);
        } else {
          const LOCAL_PREFIX = 'rocky_local::';
          const raw = localStorage.getItem(LOCAL_PREFIX + account);
          const p = raw ? JSON.parse(raw) : { memories: {}, threads: {} };
          p.memories = p.memories || {};
          p.memories[flag] = { value, timestamp: (new Date()).toISOString() };
          localStorage.setItem(LOCAL_PREFIX + account, JSON.stringify(p));
        }
      }
    } catch (err) {
      // fallback to local push
      if (window.Rocky && typeof window.Rocky.pushLocalMemory === 'function') {
        window.Rocky.pushLocalMemory(account, flag, value);
      }
    }
  }

  // Ping agent (with optional silent mode)
  async function pingAgent(msg, silent=false) {
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return;
    try {
      const API = (window.Rocky && window.Rocky.API_BASE) ? window.Rocky.API_BASE : (window.API || 'http://127.0.0.1:8000');
      const res = await fetch(`${API}/agent/${encodeURIComponent(account)}`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ message })
  });
  const j = await res.json();
  if (j && j.reply) {
  appendAssistant(`${j.personality?.signature || ''} ${j.reply}`);
  }
     }

  // Restore toggle states (backend ‚Üí local fallback)
  async function restorePersonalityFlags(silent=false) {
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return;
    try {
      const API = (window.Rocky && window.Rocky.API_BASE) ? window.Rocky.API_BASE : (window.API || 'http://127.0.0.1:8000');
      const resHighest = await fetch(`${API}/recall/${encodeURIComponent(account)}/highestPers`);
      const highest = resHighest.ok ? (await resHighest.json()).value || (await resHighest.json()) : null;
      const resImmortal = await fetch(`${API}/recall/${encodeURIComponent(account)}/immortalPers`);
      const immortal = resImmortal.ok ? (await resImmortal.json()).value || (await resImmortal.json()) : null;
      const ghost = await fetchJSON(`${API}/recall/${encodeURIComponent(account)}/ghostPers`);
      $('ghostPers').checked = !!(ghost?.value || ghost);
      if ($('ghostPers').checked) await pingAgent('bro ghost', true);

      if (document.getElementById('highestPers')) document.getElementById('highestPers').checked = !!(highest?.value || highest);
      if (document.getElementById('immortalPers')) document.getElementById('immortalPers').checked = !!(immortal?.value || immortal);
    } catch {
      const local = (function(){
        try { return JSON.parse(localStorage.getItem('rocky_local::' + (localStorage.getItem('rocky_account')||''))) || {memories:{}}; } catch(e) { return {memories:{}}; }
      })();
      if (document.getElementById('highestPers')) document.getElementById('highestPers').checked = !!local.memories?.highestPers;
      if (document.getElementById('immortalPers')) document.getElementById('immortalPers').checked = !!local.memories?.immortalPers;
    }

    // auto-ping agent silently so GPT is aligned
    if (document.getElementById('highestPers') && document.getElementById('highestPers').checked) await pingAgent('bro personality highest', silent);
    if (document.getElementById('immortalPers') && document.getElementById('immortalPers').checked) await pingAgent('bro personality immortal', silent);
  }

  // Highest Personality toggle
  const highestPersEl = document.getElementById('highestPers');
  if (highestPersEl) {
    highestPersEl.addEventListener('change', async e => {
      const account = localStorage.getItem('rocky_account') || '';
      if (!account) return alert('Login first');
      const on = e.target.checked;
      if (window.Rocky && typeof window.Rocky.appendAssistant === 'function') window.Rocky.appendAssistant(on ? '‚ö° Highest Personality activated' : '‚ôª Highest Personality reset');
      else console.log(on ? '‚ö° Highest Personality activated' : '‚ôª Highest Personality reset');
      await setPersonalityFlag("highestPers", on);
      await pingAgent(on ? 'bro personality highest' : 'bro personality reset');
    });
  }

  // Immortal Personality toggle
  const immortalPersEl = document.getElementById('immortalPers');
  if (immortalPersEl) {
    immortalPersEl.addEventListener('change', async e => {
      const account = localStorage.getItem('rocky_account') || '';
      if (!account) return alert('Login first');
      const on = e.target.checked;
      if (window.Rocky && typeof window.Rocky.appendAssistant === 'function') window.Rocky.appendAssistant(on ? '‚ôæÔ∏è Immortal Personality activated' : '‚ôª Immortal Personality reset');
      else console.log(on ? '‚ôæÔ∏è Immortal Personality activated' : '‚ôª Immortal Personality reset');
      await setPersonalityFlag("immortalPers", on);
      await pingAgent(on ? 'bro immortal' : 'bro personality reset');
    });
  }
  
  // Ghost Personality toggle
const ghostPersEl = document.getElementById('ghostPers');
if (ghostPersEl) {
  ghostPersEl.addEventListener('change', async e => {
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return alert('Login first');
    const on = e.target.checked;
    if (window.Rocky && typeof window.Rocky.appendAssistant === 'function') {
      window.Rocky.appendAssistant(on ? 'üëª Ghost Personality activated' : '‚ôª Ghost Personality reset');
    } else {
      console.log(on ? 'üëª Ghost Personality activated' : '‚ôª Ghost Personality reset');
    }
    await setPersonalityFlag("ghostPers", on);
    await pingAgent(on ? 'bro ghost' : 'bro personality reset');
  });
}
    async function pingAgent(msg, silent=false) {
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return;
    try {
      await fetch(`${window.Rocky.API_BASE || 'http://127.0.0.1:8000'}/agent/${encodeURIComponent(account)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: msg })
      });
      if (!silent) window.Rocky.appendAssistant(`‚úÖ Agent synced: ${msg}`);
    } catch {
      if (!silent) window.Rocky.appendAssistant('‚ö† Agent sync failed (offline)');
    }
  }

  // Personality selector handler
  const sel = document.getElementById('personalitySel');
  if (sel) {
    sel.addEventListener('change', async e => {
      const val = e.target.value;
      let cmd = '';
      if (val === 'highest') cmd = 'bro personality highest';
      if (val === 'immortal') cmd = 'bro immortal';
      if (val === 'ghost') cmd = 'bro ghost';
      if (val === 'default') cmd = 'bro personality reset';
      if (cmd) {
        await setPersonalityFlag('activePersonality', val);
        await pingAgent(cmd);
        window.Rocky.appendAssistant(`üîÑ Personality switched to ${val.toUpperCase()}`);
      }
    });
  }

  // Restore from memory on login
  async function restorePersonalityDropdown() {
    const account = localStorage.getItem('rocky_account') || '';
    if (!account) return;
    try {
      const res = await fetch(`${window.Rocky.API_BASE || 'http://127.0.0.1:8000'}/recall/${encodeURIComponent(account)}/activePersonality`);
      if (res.ok) {
        const j = await res.json();
        const mode = j.value || j;
        if (sel && mode) {
          sel.value = mode;
          sel.dispatchEvent(new Event('change')); // auto-apply
        }
      }
    } catch {
      // fallback to local
      const local = JSON.parse(localStorage.getItem('rocky_local::' + account) || '{}');
      if (local.memories && local.memories.activePersonality) {
        sel.value = local.memories.activePersonality.value || local.memories.activePersonality;
        sel.dispatchEvent(new Event('change'));
      }
    }
  }

  // call restore after login
  document.addEventListener('DOMContentLoaded', restorePersonalityDropdown);
</script>

<script>
/* Manual restore via Load Personality button */
  const loadPersBtn = document.getElementById('loadPers');
  if (loadPersBtn) {
    loadPersBtn.addEventListener('click', async () => {
      await restorePersonalityFlags();
      if (window.Rocky && typeof window.Rocky.appendAssistant === 'function') window.Rocky.appendAssistant('‚ôª Personality toggles restored (manual)');
      else console.log('‚ôª Personality toggles restored (manual)');
    });
  }

  // note: we replaced top-level await(loadMemories) calls with non-await safe calls below

<script>
/* =========================
   Production-ready JS (fixed)
   - grouped into a single IIFE so helpers are defined before use
   - exported a few helpers via window.Rocky for earlier handlers
   - removed top-level await calls
   ========================= */

(() => {
  'use strict';

  // === Config ===
  const API = 'http://127.0.0.1:8000'; // change if your API lives elsewhere
  const LOCAL_PREFIX = 'rocky_local::';
  let account = localStorage.getItem('rocky_account') || '';
  let serverAlive = false;
  let memEntries = [];
  let currentPage = 1;
  let pageSize = parseInt(document.getElementById('pageSize').value || '8', 10);
  let valuePageSize = parseInt(document.getElementById('valuePageSize').value || '1200', 10);
  let modalChunks = [], modalIndex = 0;
  let systemPromptSaved = '';

  // expose API base for other scripts
  window.Rocky = window.Rocky || {};
  window.Rocky.API_BASE = API;

  // === Short helpers ===
  const $ = id => document.getElementById(id);
  const esc = s => s == null ? '' : String(s);
  const nowISO = () => (new Date()).toISOString();
  const safeParseJSON = (s, fallback = {}) => { try { return JSON.parse(s); } catch { return fallback; } };

  function chunkString(s, n) {
    if (!s) return [];
    const out = [];
    for (let i = 0; i < s.length; i += n) out.push(s.slice(i, i + n));
    return out;
  }

  // === UI helpers ===
  function setServerStatus(ok) {
    serverAlive = !!ok;
    const srv = $('srv');
    if (!srv) return;
    srv.textContent = 'Server: ' + (ok ? 'online' : 'offline');
    srv.style.color = ok ? '#065f46' : '#ef4444';
  }
  setServerStatus(false);

  function showLoginUI() {
    if (account) {
      if ($('email')) $('email').style.display = 'none';
      if ($('login')) $('login').style.display = 'none';
      if ($('logout')) $('logout').style.display = 'inline-block';
      if ($('curAccount')) $('curAccount').textContent = account;
    } else {
      if ($('email')) $('email').style.display = 'inline-block';
      if ($('login')) $('login').style.display = 'inline-block';
      if ($('logout')) $('logout').style.display = 'none';
      if ($('curAccount')) $('curAccount').textContent = '(not logged)';
    }
  }

  showLoginUI();

  // === Server ping (debounced / safe) ===
  async function checkServer() {
    try {
      const r = await fetch(API + '/', { method: 'HEAD' });
      setServerStatus(r && (r.status >= 200 && r.status < 500));
    } catch (e) {
      setServerStatus(false);
    }

    // auto sync if enabled
    try {
      const autoEl = document.getElementById('autoSync');
      if (serverAlive && account && (autoEl && autoEl.checked)) {
        tryAutoSync();
      }
    } catch (e) { /* ignore */ }
  }
  // faster but safe interval
  setInterval(checkServer, 3500);
  checkServer();

  // === Safe fetch wrapper ===
  async function fetchJSON(url, opts = {}) {
    try {
      const res = await fetch(url, opts);
      if (!res.ok) {
        // bubble up but include status text
        const text = await res.text().catch(() => '');
        throw new Error(`${res.status} ${res.statusText} ${text ? ' - ' + text : ''}`);
      }
      // Attempt parse json, fallback to null
      const ct = res.headers.get('content-type') || '';
      if (ct.includes('application/json')) {
        return await res.json();
      } else {
        return null;
      }
    } catch (err) {
      console.warn('fetchJSON failed', url, err);
      throw err;
    }
  }

  // attach to window.Rocky for other inline scripts
  window.Rocky.fetchJSON = fetchJSON;

  // === Chat helpers (append) ===
  function appendUser(text) {
    const d = document.createElement('div');
    d.className = 'msg user';
    d.innerHTML = `<strong>You:</strong> ${esc(text)}`;
    const msgs = $('msgs');
    if (msgs) {
      msgs.appendChild(d);
      msgs.scrollTop = msgs.scrollHeight;
    }
  }
  function appendAssistant(text) {
    const d = document.createElement('div');
    d.className = 'msg assistant';
    d.innerHTML = `<strong>Assistant:</strong> ${esc(text)}`;
    const msgs = $('msgs');
    if (msgs) {
      msgs.appendChild(d);
      msgs.scrollTop = msgs.scrollHeight;
    } else {
      console.log('Assistant:', text);
    }
  }

  // expose appendAssistant
  window.Rocky.appendAssistant = appendAssistant;

  // === Local fallback storage ===
  function localStoreKey(acc) { return LOCAL_PREFIX + acc; }
  function getLocal(acc) {
    const raw = localStorage.getItem(localStoreKey(acc));
    return safeParseJSON(raw, { memories: {}, threads: {} });
  }
  function pushLocalMemory(acc, k, v) {
    const p = getLocal(acc);
    p.memories = p.memories || {};
    p.memories[k] = { value: v, timestamp: nowISO() };
    localStorage.setItem(localStoreKey(acc), JSON.stringify(p));
  }
  function pushLocalThread(acc, tid, msg) {
    const p = getLocal(acc);
    p.threads = p.threads || {};
    p.threads[tid] = p.threads[tid] || [];
    p.threads[tid].push(msg);
    localStorage.setItem(localStoreKey(acc), JSON.stringify(p));
  }

  // expose local helpers
  window.Rocky.pushLocalMemory = pushLocalMemory;
  window.Rocky.pushLocalThread = pushLocalThread;
  window.Rocky.pushLocal = pushLocalMemory; // alias
  window.Rocky.getLocal = getLocal;

  // === Memory CRUD & UI ===
  async function loadMemories(q = null) {
    if (!account) return;
    const memContainer = document.getElementById('memList');
    if (memContainer) memContainer.textContent = 'Loading...';

    try {
      if (serverAlive && q) {
        const data = await fetchJSON(`${API}/search?q=${encodeURIComponent(q)}&limit=200`);
        const mems = (data && data.memories) || [];
        memEntries = mems.map(m => ({ key: m.key || m._id, value: m.value, raw: m }));
      } else if (serverAlive) {
        const j = await fetchJSON(`${API}/export/${encodeURIComponent(account)}`);
        const mems = (j && j.memories) || {};
        memEntries = Object.entries(mems).map(([k, v]) => ({
          key: k.split('::').pop(),
          value: (v && v.value !== undefined) ? v.value : v,
          raw: v
        }));
      } else {
        const local = getLocal(account);
        memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({
          key: k,
          value: (v && v.value !== undefined) ? v.value : v,
          raw: v
        }));
      }
    } catch (e) {
      console.warn('loadMemories catch', e);
      const local = getLocal(account);
      memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({
        key: k,
        value: (v && v.value !== undefined) ? v.value : v,
        raw: v
      }));
    }

    // paging
    pageSize = parseInt((document.getElementById('pageSize') && document.getElementById('pageSize').value) || pageSize, 10);
    const total = memEntries.length;
    const pages = Math.max(1, Math.ceil(total / pageSize));
    if (currentPage > pages) currentPage = pages;
    const start = (currentPage - 1) * pageSize;
    const end = start + pageSize;
    renderMemList(memEntries.slice(start, end), total, currentPage, pages);
  }

  function renderMemList(items = [], total = 0, page = 1, pages = 1) {
    const container = $('memList');
    if (!container) return;
    container.innerHTML = '';
    const countEl = $('memCount');
    if (countEl) countEl.textContent = String(total);

    if (!items.length) {
      container.innerHTML = '<div class="small">No memories</div>';
      if ($('pageInfo')) $('pageInfo').textContent = `Page ${page}/${pages}`;
      return;
    }

    // Bulk action bar with Select All
    const bulkBar = document.createElement('div');
    bulkBar.style.marginBottom = '8px';
    bulkBar.innerHTML = `
      <label style="margin-right:12px">
        <input type="checkbox" id="selectAllMem" > Select All
      </label>
      <button class="btn btn-ghost" id="deleteSelected">üóë Delete Selected</button>
    `;
    container.appendChild(bulkBar);

    items.forEach(it => {
      const div = document.createElement('div');
      div.className = 'memItem';
      div.innerHTML = `
        <input type="checkbox" class="memCheck" data-key="${esc(it.key)}" style="margin-right:8px">
        <div style="flex:1">
          <div class="memKey">${esc(it.key)}</div>
          <div class="memVal">${esc(it.value)}</div>
        </div>
      `;

      const controls = document.createElement('div');
      controls.className = 'controls';

      const view = document.createElement('button');
      view.className = 'btn btn-ghost';
      view.textContent = 'View';
      view.addEventListener('click', () => openViewer(it));

      const forget = document.createElement('button');
      forget.className = 'btn btn-ghost';
      forget.style.background = 'var(--danger)';
      forget.style.color = '#fff';
      forget.textContent = 'Forget';
      forget.addEventListener('click', () => forgetMem(it.key));

      controls.appendChild(view);
      controls.appendChild(forget);
      div.appendChild(controls);

      container.appendChild(div);
    });

    // Select All toggle
    const selectAll = $('selectAllMem');
    if (selectAll) {
      selectAll.addEventListener('change', () => {
        const checks = document.querySelectorAll('.memCheck');
        checks.forEach(cb => { cb.checked = selectAll.checked; });
      });
    }

    // Multi-delete handler
    const bulkBtn = $('deleteSelected');
    if (bulkBtn) {
      bulkBtn.addEventListener('click', async () => {
        const selected = Array.from(document.querySelectorAll('.memCheck:checked')].map(cb => cb.dataset.key);
        if (!selected.length) return alert('No memories selected');
        if (!confirm(`Delete ${selected.length} memories?`)) return;
        for (const key of selected) {
          await forgetMem(key);
        }
        appendAssistant(`üóë Deleted ${selected.length} memories`);
        loadMemories();
      });
    }

    if ($('pageInfo')) $('pageInfo').textContent = `Page ${page} / ${pages}`;
  }


  // === Sync local -> server ===
  async function tryAutoSync(force = false) {
    if (!account) return;
    const local = getLocal(account);
    const has = ((local.memories && Object.keys(local.memories).length) || (local.threads && Object.keys(local.threads).length));
    if (!has && !force) return;
    try {
      const res = await fetch(`${API}/sync_local/${encodeURIComponent(account)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(local)
      });
      if (res.ok) {
        localStorage.removeItem(localStoreKey(account));
        appendAssistant('Local data synced to server');
        await loadMemories();
      } else {
        console.warn('sync failed', res.status);
      }
    } catch (e) {
      console.warn('sync failed', e);
    }
  }
  if ($('syncBtn')) $('syncBtn').addEventListener('click', () => tryAutoSync(true));

  // === Search ===
  if ($('searchBtn')) {
    $('searchBtn').addEventListener('click', async () => {
      const q = ($('searchQ').value || '').trim(); currentPage = 1;
      if (!q) { loadMemories(); return; }
      if (serverAlive) { loadMemories(q); } else {
        const local = getLocal(account);
        memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({ key: k, value: v.value || v, raw: v }))
          .filter(m => (m.key && m.key.toLowerCase().includes(q.toLowerCase())) || (String(m.value || '').toLowerCase().includes(q.toLowerCase())));
        renderMemList(memEntries.slice(0, pageSize), memEntries.length, 1, Math.max(1, Math.ceil(memEntries.length / pageSize)));
      }
    });
  }

  // === Export ===
  async function triggerExport() {
    if (!account) return alert('Login first');
    try {
      const res = await fetch(`${API}/export/${encodeURIComponent(account)}`);
      const data = await res.json();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${String(account).replace(/[^a-z0-9@.\-]/gi, '_')}_export.json`;
      a.click();
    } catch (e) {
      alert('Export failed ‚Äî server maybe offline');
    }
  }
  if ($('exportBtn')) $('exportBtn').addEventListener('click', triggerExport);
  if ($('navExport')) $('navExport').addEventListener('click', triggerExport);

  // === Chat flow (send message, agent) ===
  if ($('messageBox')) {
    $('messageBox').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if ($('send')) $('send').click();
      }
    });
  }

  if ($('send')) {
    $('send').addEventListener('click', async () => {
      const text = ($('messageBox').value || '').trim();
      if (!text) return;
      if (!account) return alert('Login first');
      appendUser(text);
      $('messageBox').value = '';
      pushLocalThread(account, 'session', { role: 'user', content: text, timestamp: nowISO() });

      try {
        const use_llm = !!($('useLLM') && $('useLLM').checked);
        const res = await fetch(`${API}/agent/${encodeURIComponent(account)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text, use_llm })
        });
        const j = await res.json();
        const reply = j.reply || j.suggested_reply || '[no reply]';
        appendAssistant(reply);
        pushLocalThread(account, 'session', { role: 'assistant', content: reply, timestamp: nowISO() });
        await loadMemories();
      } catch (e) {
        appendAssistant('[Server unreachable ‚Äî response saved locally]');
        pushLocalThread(account, 'session', { role: 'assistant', content: '[saved locally]', timestamp: nowISO() });
      }
    });
  }

  if ($('clearChat')) $('clearChat').addEventListener('click', () => { const m=$('msgs'); if(m) m.innerHTML=''; });

  // Insert last 3 mems into composer
  if ($('refMemsBtn')) {
    $('refMemsBtn').addEventListener('click', () => {
      const slice = memEntries.slice(-3).map(m => `${m.key}: ${m.value}`).join('\n');
      if ($('messageBox')) {
        $('messageBox').value += '\n\n[Ref Memories]\n' + slice;
      }
    });
  }

  // Small helper to show/hide the inline viewer panel placed inside the settings side panel.
  function showViewerPanel() {
    const vp = $('viewerPanel');
    if (!vp) return;
    vp.style.display = 'block';
  }
  function hideViewerPanel() {
    const vp = $('viewerPanel');
    if (!vp) return;
    vp.style.display = 'none';
  }

  /* Save/Load personality ‚Äî extended with agent + creativity */
  const savePersEl = $('savePers');
  if (savePersEl) {
    savePersEl.onclick = async () => {
      if (!account) {
        alert('Login first');
        return;
      }
      // ---- Personality UI sync (keep quick + stable in sync) ----
      if ($('toneSel') && $('toneSelStable')) {
        $('toneSel').addEventListener('change', e => {
          $('toneSelStable').value = e.target.value;
        });
        $('toneSelStable').addEventListener('change', e => {
          $('toneSel').value = e.target.value;
        });
      }

      if ($('sigInput') && $('sigInputStable')) {
        $('sigInput').addEventListener('input', e => {
          $('sigInputStable').value = e.target.value;
        });
        $('sigInputStable').addEventListener('input', e => {
          $('sigInput').value = e.target.value;
        });
      }

      // ---- SAVE ----
      const pers = {
        agentMode: !!($('agentMode') && $('agentMode').checked),
        aggressiveness: parseInt($('agentAggressiveness') ? $('agentAggressiveness').value : 5),
        tone: $('toneSel') ? $('toneSel').value : 'consistent',
        signature: $('sigInput') ? $('sigInput').value || '' : '',
        creativity: parseInt($('creativity') ? $('creativity').value : 7),
      };

      try {
        await fetch(`${API}/remember`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ account, key: '__personality__', value: pers })
        });
        appendAssistant('‚úÖ Stable personality saved');
      } catch (e) {
        pushLocalMemory(account, '__personality__', pers);
        appendAssistant('‚ö† Personality saved locally (server offline)');
      }

      // ---- LOAD / APPLY BACK TO UI ----
      let loaded = null;

      // 1) Try server first
      try {
        const res = await fetch(`${API}/recall/${encodeURIComponent(account)}/__personality__`);
        if (res.ok) {
          const j = await res.json();
          loaded = j.value || j;
        }
      } catch (e) {
        console.warn('Server recall failed', e);
      }

      // 2) Fallback to local cache
      if (!loaded) {
        const local = getLocal(account);
        if (local.memories && local.memories['__personality__']) {
          loaded = local.memories['__personality__'].value || local.memories['__personality__'];
        }
      }

      // 3) Apply to UI
      if (loaded) {
        if (loaded.agentMode !== undefined) { if ($('agentMode')) $('agentMode').checked = !!loaded.agentMode; }
        if (loaded.aggressiveness !== undefined) { if ($('agentAggressiveness')) $('agentAggressiveness').value = loaded.aggressiveness; }
        if (loaded.creativity !== undefined) {
          if ($('creativity')) { $('creativity').value = loaded.creativity; if ($('creativityLabel')) $('creativityLabel').textContent = loaded.creativity; }
        }
        if (loaded.tone && $('toneSel')) $('toneSel').value = loaded.tone;
        if (loaded.signature && $('sigInput')) $('sigInput').value = loaded.signature;

        appendAssistant('‚úÖ Personality loaded');
      } else {
        appendAssistant('‚ö† No saved personality found');
      }
    };
  }

  if ($('loadPers')) {
    $('loadPers').addEventListener('click', async () => {
      if (!account) return alert('Login first');
      try {
        const res = await fetch(`${API}/recall/${encodeURIComponent(account)}/__personality__`);
        if (res.ok) {
          const j = await res.json();
          const p = j.value || j;
          if ($('toneSel')) $('toneSel').value = p.tone || 'consistent';
          if ($('styleSel')) $('styleSel').value = p.style || 'cofounder-high-energy';
          if ($('sigInput')) $('sigInput').value = p.signature || 'üíéüî•';
          appendAssistant('Personality loaded from server');
          return;
        }
      } catch (e) { /* ignore */ }
      const local = getLocal(account);
      const p = (local.memories && local.memories['__personality__'] && local.memories['__personality__'].value) || null;
      if (p) {
        if ($('toneSel')) $('toneSel').value = p.tone || 'consistent';
        if ($('styleSel')) $('styleSel').value = p.style || 'cofounder-high-energy';
        if ($('sigInput')) $('sigInput').value = p.signature || 'üíéüî•';
        appendAssistant('Loaded personality locally');
      } else appendAssistant('No saved personality found');
    });
  }

  // system prompt
  if ($('savePrompt')) {
    $('savePrompt').addEventListener('click', () => {
      systemPromptSaved = $('systemPrompt').value || '';
      appendAssistant('System prompt saved (applies when LLM enabled)');
    });
  }
  if ($('clearPrompt')) {
    $('clearPrompt').addEventListener('click', () => {
      if ($('systemPrompt')) $('systemPrompt').value = '';
      systemPromptSaved = '';
      appendAssistant('System prompt cleared');
    });
  }

  // agent runner (guarded in case runAgentOnce button is not present)
  const runAgentOnceEl = $('runAgentOnce');
  if (runAgentOnceEl) {
    runAgentOnceEl.addEventListener('click', async () => {
      if (!account) return alert('Login first');
      const local = getLocal(account);
      const last = (local.threads && local.threads['session'] && local.threads['session'].slice(-1)[0]) || null;
      if (!last) return alert('No session messages to run agent on');
      try {
        const res = await fetch(`${API}/agent/${encodeURIComponent(account)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: last.content, use_llm: false })
        });
        const j = await res.json();
        appendAssistant(j.reply || j.suggested_reply || '[no reply]');
      } catch (e) {
        appendAssistant('[Agent run failed ‚Äî offline]');
      }
    });
  }

  // quick insert tools
  if ($('insertLastMem')) $('insertLastMem').addEventListener('click', () => {
    if ($('messageBox')) $('messageBox').value += memEntries.slice(-3).map(m => `${m.key}: ${m.value}`).join('\n');
  });
  if ($('insertLastHist')) $('insertLastHist').addEventListener('click', () => {
    const hist = (getLocal(account).threads && getLocal(account).threads.session || []).slice(-5).map(m => `${m.role}: ${m.content}`).join('\n');
    if ($('messageBox')) $('messageBox').value += '\n\n' + hist;
  });

  // forget all local
  if ($('forgetAll')) $('forgetAll').addEventListener('click', () => {
    if (!account) return;
    localStorage.removeItem(localStoreKey(account));
    appendAssistant('All local memories cleared');
    loadMemories();
  });

  // export all in settings modal
  if ($('exportAll')) $('exportAll').addEventListener('click', triggerExport);

  // Insert last 3 mems into composer (ref button)
  if ($('refMemsBtn')) {
    $('refMemsBtn').addEventListener('click', () => {
      if (!memEntries.length) {
        alert('No memories available');
        return;
      }
      const slice = memEntries.slice(-3);
      const text = slice.map(m => `${m.key}: ${m.value}`).join('\n');
      const box = $('messageBox');
      if (box) {
        box.value = (box.value ? box.value + '\n' : '') + text;
        box.focus();
      }
    });
  }

  /* === Sidebar navigation toggle === */
  function showPanel(panelId) {
    // hide all panels
    ['chatPanel', 'memoryPanel', 'settingsPanel'].forEach(id => {
      const el = $(id);
      if (el) el.classList.add('hidden');
    });

    // deactivate all nav buttons
    ['navChat', 'navMemory', 'navSettings'].forEach(id => {
      const btn = $(id);
      if (btn) btn.classList.remove('active');
      if (btn) btn.setAttribute('aria-pressed', 'false');
    });

    // show requested panel
    const panel = $(panelId);
    if (panel) panel.classList.remove('hidden');

    // mark correct button active
    if (panelId === 'chatPanel') {
      if ($('navChat')) { $('navChat').classList.add('active'); $('navChat').setAttribute('aria-pressed', 'true'); }
    }
    if (panelId === 'memoryPanel') {
      if ($('navMemory')) { $('navMemory').classList.add('active'); $('navMemory').setAttribute('aria-pressed', 'true'); }
      loadMemories(); // refresh memory list when opened
    }
    if (panelId === 'settingsPanel') {
      if ($('navSettings')) { $('navSettings').classList.add('active'); $('navSettings').setAttribute('aria-pressed', 'true'); }
    }
  }

  if ($('navChat')) $('navChat').onclick = () => showPanel('chatPanel');
  if ($('navMemory')) $('navMemory').onclick = () => showPanel('memoryPanel');
  if ($('navSettings')) $('navSettings').onclick = () => showPanel('settingsPanel');

  /* === Default Startup === */
  document.addEventListener('DOMContentLoaded', () => {
    showPanel('chatPanel');
    if ($('navChat')) { $('navChat').classList.add('active'); $('navChat').setAttribute('aria-pressed', 'true'); }
  });

  // === Login / Session ===
  if ($('login')) {
    $('login').addEventListener('click', async () => {
      const em = ($('email').value || '').trim();
      if (!em || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(em)) { alert('Enter a valid email'); return; }
      account = em;
      localStorage.setItem('rocky_account', account);
      showLoginUI();
      try {
        // try to create server session silently
        await fetchJSON(API + '/session', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ account }) });
      } catch (e) { /* ignore */ }
      try {
        await fetchJSON(API + '/remember', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ account, key: 'email', value: account }) });
      } catch (e) { /* ignore */ }
      appendAssistant(`Logged in as ${account}`);
      await loadMemories();

      // üöÄ Auto-restore Highest + Immortal Personality on login
      try {
        await restorePersonalityFlags(true);
        appendAssistant('‚ôª Personality toggles restored & agent synced (auto)');
      } catch (e) { /* ignore */ }
    });
  }

  if ($('logout')) {
    $('logout').addEventListener('click', () => {
      localStorage.removeItem('rocky_account');
      account = '';
      if ($('email')) $('email').value = '';  // clear UI
      showLoginUI();
      appendAssistant('Logged out');
      memEntries = [];
      renderMemList([]);
      showPanel('chatPanel'); // reset to chat
    });
  }

  // Insert last 3 mems into composer (another ref handler - safe)
  if ($('refMemsBtn')) {
    $('refMemsBtn').addEventListener('click', () => {
      if (!memEntries.length) {
        alert('No memories available');
        return;
      }
      const slice = memEntries.slice(-3);
      const text = slice.map(m => `${m.key}: ${m.value}`).join('\n');
      const box = $('messageBox');
      if (box) {
        box.value = (box.value ? box.value + '\n' : '') + text;
        box.focus();
      }
    });
  }

  // === Init ===
  (async function init() {
    if (account) {
      if ($('email')) $('email').value = account;
      showLoginUI();
      appendAssistant('Welcome back ‚Äî account loaded');
      await loadMemories();
      // if server not reachable, show local cache immediately
      if (!serverAlive) {
        const local = getLocal(account);
        memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({ key: k, value: v.value || v, raw: v }));
        renderMemList(memEntries, memEntries.length, 1, Math.max(1, Math.ceil(memEntries.length / pageSize)));
      }
    } else {
      appendAssistant('Welcome. Login with email to namespace memory to your account.');
    }
    if ($('navChat')) $('navChat').classList.add('active');
    showPanel('chatPanel');
  })();

  // expose for debugging / console
  window.Rocky.loadMemories = loadMemories;
  window.Rocky.tryAutoSync = tryAutoSync;
  window.Rocky.getLocal = getLocal;
  window.Rocky.fetchJSON = fetchJSON;
  window.Rocky.appendAssistant = appendAssistant;
  window.Rocky.pushLocalMemory = pushLocalMemory;
  window.Rocky.pushLocalThread = pushLocalThread;

})();
// ---- Creativity slider live label update ----
if ($('creativity') && $('creativityLabel')) {
  $('creativity').addEventListener('input', e => {
    $('creativityLabel').textContent = e.target.value;
  });
}
</script>
</div></div></div></div></div></div>
</body>
</html>
