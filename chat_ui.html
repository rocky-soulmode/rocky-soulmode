<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" >
  <meta name="viewport" content="width=device-width,initial-scale=1" >
  <title>Rocky Soulmode ‚Äî Chat Memory (Polished)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* ---------- Theme & layout (kept your polished design, cleaned) ---------- */
    :root{
      --bg: #f6f9fc;
      --panel: #ffffff;
      --muted: #6b7280;
      --accent: #0ea5a0;
      --accent-2: #ffb020;
      --glass: rgba(2,6,23,0.04);
      --card: #ffffff;
      --danger:#ef4444;
      --shadow: 0 8px 24px rgba(2,6,23,0.06);
      --radius: 12px;
      --max-width: 1200px;
      --font: Inter, system-ui, "Segoe UI", Arial, sans-serif;
      --muted-2: #9aa6b2;
    }
    * { box-sizing: border-box; }
    html,body { height: 100%; margin: 0; font-family: var(--font); background: linear-gradient(180deg,#f3f7fb,#eef6fb); color: #041826; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    a { color: inherit; text-decoration: none; }
    button { font: inherit; }

    .app { display:flex; min-height:100vh; gap:18px; padding:18px; }

    /* Sidebar */
    .sidebar {
      width:96px;
      background: linear-gradient(180deg,#fff,#f8fbff);
      border-radius:var(--radius);
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:12px;
      gap:14px;
      position:sticky;
      top:18px;
      height:calc(100vh - 36px);
      box-shadow:var(--shadow);
      border:1px solid rgba(2,6,23,0.03);
    }
    .logo {
      width:56px; height:56px; border-radius:12px;
      background: linear-gradient(135deg,var(--accent),var(--accent-2));
      display:flex; align-items:center; justify-content:center; color:#012; font-weight:700; box-shadow:0 8px 28px rgba(14,165,160,0.12);
      font-size:18px;
    }
    .navBtn {
      width:56px; height:56px; border-radius:10px; background:transparent; border:0; cursor:pointer;
      display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:18px; transition:all .18s ease;
    }
    .navBtn:hover{ transform:translateY(-3px); }
    .navBtn.active { background:var(--glass); color:var(--accent); }
    .bottomArea { margin-top:auto; }

    /* Main area */
    .main { flex:1; display:flex; flex-direction:column; }
    header { display:flex; align-items:center; justify-content:space-between; padding:14px 20px; border-radius:12px; }
    .header-left { display:flex; gap:14px; align-items:center; }
    .title { font-weight:700; font-size:16px; }
    .server-status { font-size:13px; color:var(--muted); }
    .header-actions { display:flex; gap:10px; align-items:center; }

    .btn { padding:8px 12px; border-radius:10px; border:0; cursor:pointer; font-weight:600; }
    .btn-primary { background:var(--accent); color:#022; box-shadow:0 6px 18px rgba(14,165,160,0.12); }
    .btn-ghost { background:transparent; border:1px solid rgba(2,6,23,0.06); color:var(--muted); }

    .layout { display:flex; gap:18px; padding:18px; max-width:var(--max-width); margin:16px auto; width:100%; box-sizing:border-box; }
    .panel { background:var(--panel); border-radius:var(--radius); box-shadow:var(--shadow); padding:14px; border:1px solid rgba(2,6,23,0.03); }

    /* Chat */
    .chatCol { flex:1; display:flex; flex-direction:column; height:74vh; min-width: 420px; }
    #msgs { flex:1; overflow:auto; padding:16px; display:flex; flex-direction:column; gap:10px; border-radius:10px; background:linear-gradient(180deg,#fbfeff,#f6fbff); }
    .msg { max-width:78%; padding:12px; border-radius:12px; line-height:1.4; word-break:break-word; box-shadow:0 4px 12px rgba(2,6,23,0.03); position:relative; transition:transform .12s ease, opacity .12s ease; }
    .msg .meta{ display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted-2); margin-bottom:6px }
    .msg .avatar{ width:28px;height:28px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;font-weight:700;margin-right:8px }
    .user { align-self:flex-end; background:linear-gradient(90deg, rgba(14,165,160,0.12), rgba(14,165,160,0.03)); color:#053633; }
    .assistant { align-self:flex-start; background:linear-gradient(90deg, rgba(255,176,32,0.08), rgba(255,176,32,0.02)); color:#4b2f00; }

    .composer { display:flex; gap:12px; align-items:flex-end; margin-top:12px; }
    textarea { flex:1; min-height:52px; max-height:260px; padding:12px; border-radius:10px; border:1px solid rgba(2,6,23,0.06); resize:vertical; font-size:14px; font-family:var(--font); }

    /* right column / memories */
    .sideCol { width:380px; display:flex; flex-direction:column; gap:12px; }
    .searchRow { display:flex; gap:8px; }
    input[type="text"], input[type="email"], textarea { padding:10px; border-radius:10px; border:1px solid rgba(2,6,23,0.06); width:100%; font-size:14px; }
    .memList { max-height:46vh; overflow:auto; border-radius:8px; padding:6px; display:flex; flex-direction:column; gap:8px; }
    .memItem { display:flex; justify-content:space-between; gap:8px; padding:10px; border-radius:8px; border:1px solid rgba(2,6,23,0.03); background:linear-gradient(180deg,#fff,#fbfdff); align-items:flex-start; }
    .memKey { font-weight:600; color:#06222b; }
    .memVal { color:var(--muted); font-size:13px; white-space:pre-wrap; max-height:72px; overflow:hidden; }
    .controls { display:flex; gap:6px; }
    .pager { display:flex; gap:8px; align-items:center; justify-content:center; padding-top:8px; }
    .badge { background:#eef6f5; color:#065; padding:6px 10px; border-radius:999px; font-weight:600; }

    /* typing indicator */
    .typing { display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted-2); }
    .dot{ width:8px; height:8px; border-radius:50%; background:var(--muted-2); opacity:0.6; animation:blink 1s infinite; }
    .dot:nth-child(2){ animation-delay:0.15s }
    .dot:nth-child(3){ animation-delay:0.3s }
    @keyframes blink{0%{opacity:.2;transform:translateY(0)}50%{opacity:1;transform:translateY(-4px)}100%{opacity:.2;transform:translateY(0)}}

    /* modal */
    .modal { position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(2,6,23,0.45); display:none; align-items:center; justify-content:center; z-index:60; }
    .modal.show { display:flex; }
    .modalCard { width:92%; max-width:980px; background:var(--panel); border-radius:12px; padding:18px; box-shadow:0 20px 60px rgba(2,6,23,0.3); }
    .row { display:flex; gap:8px; align-items:center; }
    .small { font-size:13px; color:var(--muted); }
    .switch { display:inline-flex; align-items:center; gap:8px; }
    .sideNavTitle { writing-mode:vertical-rl; text-orientation:upright; color:var(--muted); font-size:12px; }

    /* responsive */
    @media (max-width:1000px){ .layout{padding:12px;width:95%} .sideCol{display:none} .sidebar{display:flex} .chatCol{min-width:unset} }
    .hidden { display:none !important; }
  </style>
</head>
<body>

<!-- Keep essential safe hidden inputs (used by JS defaults) -->
<input type="hidden" id="pageSize" value="8">
<input type="hidden" id="valuePageSize" value="1200">
<input type="hidden" id="autoSync" value="true">
<input type="hidden" id="showRaw" value="false">

<div class="app" role="application" aria-label="Rocky Soulmode Chat Memory App">
  <!-- Sidebar -->
  <div class="sidebar" role="navigation" aria-label="Main navigation">
    <div class="logo" title="Rocky Soulmode">RS</div>
    <button class="navBtn active" id="navChat" title="Chat" aria-pressed="true">üí¨</button>
    <button class="navBtn" id="navMemory" title="Memories" aria-pressed="false">üß†</button>
    <button class="navBtn" id="navSettings" title="Settings" aria-pressed="false">‚öôÔ∏è</button>
    <div class="bottomArea">
      <button class="navBtn" id="navExport" title="Export">‚¨áÔ∏è</button>
    </div>
  </div>

  <!-- Main area -->
  <div class="main">
    <header>
      <div class="header-left">
        <div class="title">üíéüî• Rocky Soulmode ‚Äî Chat Memory</div>
        <div class="server-status small" id="srv" aria-live="polite">Server: unknown</div>
      </div>
       <div class="header-actions">
        <input id="email" type="email" placeholder="you@domain.com" aria-label="Account email" >
        <button class="btn btn-ghost" id="login">Login</button>
        <button class="btn btn-ghost" id="logout" style="display:none">Logout</button>
      </div>
    </header>

    <div class="layout" id="mainLayout" role="main">
      <!-- Chat Panel -->
      <h2 id="chat-heading" class="small" style="display:none">Chat</h2>
      <div id="chatPanel" class="chatCol panel" aria-labelledby="chat-heading">
        <div id="msgs" aria-live="polite" aria-atomic="false"></div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
          <div class="small">Account: <strong id="curAccount">(not logged)</strong></div>
          <div>
            <label class="small" for="useLLM">LLM</label>
            <input type="checkbox" id="useLLM" style="margin-left:8px" aria-label="Use LLM">
          </div>
        </div>

        <div class="composer" role="region" aria-label="Message composer">
          <textarea id="messageBox" placeholder="Type a message..." aria-label="Message input"></textarea>
          <div style="display:flex;flex-direction:column;gap:8px;min-width:140px">
            <button class="btn btn-primary" id="send">Send</button>
            <button class="btn btn-ghost" id="clearChat">Clear</button>
            <button class="btn btn-ghost" id="refMemsBtn">Insert last 3 mems</button>
          </div>
        </div>
      </div>

      <!-- Memory Panel -->
      <div id="memoryPanel" class="panel hidden" style="flex:1">
        <div class="panel" style="padding:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Memories</strong>
              <div class="small">Saved facts & notes</div>
            </div>
            <div class="badge" id="memCount">0</div>
          </div>

          <div style="margin-top:10px" class="searchRow">
            <input id="searchQ" type="text" placeholder="Search memories or messages" aria-label="Search memories" >
            <button class="btn btn-ghost" id="searchBtn">Search</button>
          </div>

          <div style="margin-top:10px">
            <div style="display:flex;gap:8px">
              <input id="addKey" type="text" placeholder="key" aria-label="memory key" >
              <button class="btn btn-primary" id="addQuick">Save</button>
            </div>
            <textarea id="addVal" placeholder="value (multi-line)" style="margin-top:8px" aria-label="memory value"></textarea>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="btn btn-ghost" id="syncBtn">Sync local ‚Üí server</button>
              <button class="btn btn-ghost" id="exportBtn">Export</button>
            </div>
          </div>
        </div>

        <div class="panel" style="padding:10px">
          <div class="memList" id="memList" role="list">No memories yet</div>
          <div class="pager" style="margin-top:8px">
            <button class="btn btn-ghost" id="prevPage">Prev</button>
            <div class="small" id="pageInfo">Page 1</div>
            <button class="btn btn-ghost" id="nextPage">Next</button>
          </div>
        </div>
      </div>

      <!-- Small area for bulk add -->
      <div style="flex-basis:100%; margin-top:8px; display:flex; gap:8px; align-items:flex-start;">
        <textarea id="bulkMemories" placeholder='Add multiple memories (JSON object or key:value per line)' style="flex:1; min-height:78px"></textarea>
        <div style="display:flex;flex-direction:column;gap:8px">
          <button class="btn btn-primary" id="bulkAddBtn">Add Multiple</button>
        </div>
      </div>

      <!-- Settings Panel -->
      <div id="settingsPanel" class="panel hidden" style="flex:1">
        <h3 id="settings-title">‚öôÔ∏è Settings & Customize ChatGPT</h3>
        <div class="small">Personalize assistant & advanced options (inline)</div>

        <div style="display:flex;gap:18px;margin-top:12px">
          <div style="flex:1">
            <div style="margin-bottom:8px"><strong>Personality</strong></div>
            <div class="row" style="gap:10px">
              <label class="small">Tone</label>
              <select id="toneSel" style="padding:8px;border-radius:8px">
                <option value="consistent">Consistent</option>
                <option value="friendly">Friendly</option>
                <option value="professional">Professional</option>
                <option value="playful">Playful</option>
              </select>
            </div>

            <div style="margin-top:8px" class="row">
              <label class="small">Style</label>
              <select id="styleSel" style="padding:8px;border-radius:8px">
                <option value="cofounder-high-energy">Cofounder ‚Äî High energy</option>
                <option value="mentor-calm">Mentor ‚Äî Calm</option>
                <option value="technical-expert">Technical expert</option>
              </select>
            </div>

            <div style="margin-top:8px" class="row">
              <label class="small">Signature</label>
              <input id="sigInput" type="text" value="üíéüî•" style="padding:8px;border-radius:8px;flex:1">
            </div>

            <div style="margin-top:12px">
              <label class="small" for="personalitySel">Personality Mode</label>
              <select id="personalitySel" style="padding:8px;border-radius:8px;flex:1">
                <option value="default">üåê Default</option>
                <option value="highest">‚ö° Highest</option>
                <option value="immortal">‚ôæÔ∏è Immortal</option>
                <option value="ghost">üëª Ghost</option>
              </select>
            </div>

            <div style="margin-top:12px" class="row">
              <label class="small">Quick Toggles</label>
              <div style="display:flex; gap:8px;">
                <label><input type="checkbox" id="highestPers"> Highest</label>
                <label><input type="checkbox" id="immortalPers"> Immortal</label>
                <label><input type="checkbox" id="ghostPers"> Ghost</label>
              </div>
            </div>

            <div style="margin-top:12px">
              <button class="btn btn-primary" id="savePers">Save Personality</button>
              <button class="btn btn-ghost" id="loadPers">Load Personality</button>
            </div>
          </div>

          <div style="flex:1">
            <div style="margin-bottom:8px"><strong>Advanced</strong></div>
            <div class="small">System prompt & LLM options</div>
            <div style="margin-top:8px">
              <textarea id="systemPrompt" rows="6" placeholder="Optional system prompt for LLM" style="width:100%;border-radius:8px;"></textarea>
              <div style="display:flex;gap:8px;margin-top:8px">
                <button class="btn btn-ghost" id="savePrompt">Save Prompt</button>
                <button class="btn btn-ghost" id="clearPrompt">Clear</button>
              </div>
            </div>
          </div>
        </div>
      </div>

    </div>

  </div>
</div>

<script>
/* =========================
   Main UI + client logic (single consolidated script)
   Safe DOM updates, robust host detection
   Enhancements: timestamps, avatars, typing indicator, improved message rendering
   ========================= */
(() => {
  'use strict';

  // ---- utilities ----
  const $ = id => document.getElementById(id);
  const nowISO = () => (new Date()).toISOString();
  const nowShort = () => new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  const safeParseJSON = (s, fallback = {}) => { try { return JSON.parse(s); } catch { return fallback; } };

  function escapeHtml(str) {
    if (str === null || str === undefined) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  // Determine API base ‚Äî prefer explicit window.API, then deployed Render, then same-origin, then localhost
  const explicitWindowAPI = (typeof window.API === 'string' && window.API.trim()) ? window.API.trim() : null;
  const explicitWindowAPIBase = (typeof window.API_BASE === 'string' && window.API_BASE.trim()) ? window.API_BASE.trim() : null;
  const RENDER_DEFAULT = 'https://rocky-soulmode.onrender.com';
  const host = window.location.hostname || '';
  const isLocal = host === '127.0.0.1' || host === 'localhost' || host === '0.0.0.0';
  const API = explicitWindowAPI || explicitWindowAPIBase || RENDER_DEFAULT || `${window.location.protocol}//${window.location.host}`;

  window.Rocky = window.Rocky || {};
  window.Rocky.API_BASE = API;

    // --- Local storage helpers (single robust implementation) ---
  function localStoreKey(acc) { return LOCAL_PREFIX + acc; }
  function getLocal(acc) {
    try {
      if (!acc) return { memories: {}, threads: {} };
      const raw = localStorage.getItem(localStoreKey(acc));
      const parsed = safeParseJSON(raw, null);
      if (!parsed || typeof parsed !== 'object') return { memories: {}, threads: {} };
      parsed.memories = parsed.memories || {};
      parsed.threads = parsed.threads || {};
      return parsed;
    } catch (e) {
      console.warn('getLocal parse error', e);
      return { memories: {}, threads: {} };
    }
  }
  function pushLocalMemory(acc, k, v) {
    const p = getLocal(acc);
    p.memories = p.memories || {};
    p.memories[k] = { value: v, timestamp: nowISO() };
    localStorage.setItem(localStoreKey(acc), JSON.stringify(p));
  }
  function pushLocalThread(acc, tid, msg) {
    const p = getLocal(acc);
    p.threads = p.threads || {};
    p.threads[tid] = p.threads[tid] || [];
    p.threads[tid].push(msg);
    localStorage.setItem(localStoreKey(acc), JSON.stringify(p));
  }
  window.Rocky.pushLocalMemory = pushLocalMemory;
  window.Rocky.pushLocalThread = pushLocalThread;


  // fetch helper with better error messages
  async function fetchJSON(url, opts = {}) {
    const res = await fetch(url, opts);
    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`${res.status} ${res.statusText}${text ? ' - ' + text : ''}`);
    }
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) return await res.json();
    return await res.text();
  }
  window.Rocky.fetchJSON = fetchJSON;

  // ---- state ----
  const LOCAL_PREFIX = 'rocky_local::';
  let account = localStorage.getItem('rocky_account') || '';
  let serverAlive = false;
  let memEntries = [];
  let currentPage = 1;
  let pageSize = parseInt(document.getElementById('pageSize').value || '8', 10);
  let typingTimer = null;

  // UI helpers
  function setServerStatus(ok) {
    serverAlive = !!ok;
    const srv = $('srv');
    if (!srv) return;
    srv.textContent = 'Server: ' + (ok ? 'online' : 'offline');
    srv.style.color = ok ? '#065f46' : '#ef4444';
  }
  setServerStatus(false);

  function showLoginUI() {
    if (account) {
      if ($('email')) $('email').style.display = 'none';
      if ($('login')) $('login').style.display = 'none';
      if ($('logout')) $('logout').style.display = 'inline-block';
      if ($('curAccount')) $('curAccount').textContent = account;
    } else {
      if ($('email')) $('email').style.display = 'inline-block';
      if ($('login')) $('login').style.display = 'inline-block';
      if ($('logout')) $('logout').style.display = 'none';
      if ($('curAccount')) $('curAccount').textContent = '(not logged)';
    }
  }
  showLoginUI();

  // periodic server check
  // Improved checkServer: tries /test/selfcheck, /health, then / ‚Äî uses GET (not HEAD)
  async function checkServer() {
    try {
      let ok = false;
      const healthUrls = [
        `${API}/test/selfcheck`,
        `${API}/health`,
        `${API}/`
      ];

      for (const url of healthUrls) {
        try {
          const r = await fetch(url, { method: 'GET', cache: 'no-store' });
          if (r && (r.status >= 200 && r.status < 500)) {
            ok = true;
            break;
          }
        } catch (err) {
          // continue to next url
        }
      }
      setServerStatus(ok);
    } catch (e) {
      setServerStatus(false);
    }

    // only auto-sync if account is set and server is live
    try {
      // safe guard: read DOM element safely
      const autoEl = document.getElementById('autoSync');
      const autoValue = (autoEl && autoEl.value) ? autoEl.value : 'true';
      if (serverAlive && account && (autoValue === "true")) {
        tryAutoSync();
      }
    } catch (e) { console.warn('checkServer autoSync fail', e); }
  }

  // make interval controllable / stoppable for debugging
  if (window._rocky_health_interval) {
    clearInterval(window._rocky_health_interval);
    window._rocky_health_interval = null;
  }
  window._rocky_health_interval = setInterval(checkServer, 3500);
  // run initial check once
  setTimeout(checkServer, 300);

  // Safe tryAutoSync
  async function tryAutoSync(force = false) {
    if (!account) {
      // if we have a console override, bind it
      if (window._rocky_account_override) {
        account = window._rocky_account_override;
        localStorage.setItem('rocky_account', account);
        showLoginUI();
      } else return;
    }

    const local = getLocal(account) || { memories: {}, threads: {} };
    const hasMem = local.memories && Object.keys(local.memories).length;
    const hasThreads = local.threads && Object.keys(local.threads).length;
    const has = (hasMem || hasThreads);

    if (!has && !force) return;
    try {
      const res = await fetch(`${API}/sync_local/${encodeURIComponent(account)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(local)
      });
      if (res.ok) {
        localStorage.removeItem(localStoreKey(account));
        appendAssistant('Local data synced to server');
        await loadMemories();
      } else {
        console.warn('sync failed', res.status, await res.text().catch(()=>'')); // better debug
      }
    } catch (e) {
      console.warn('sync failed', e);
    }
  }

  // expose helper debug function to console
  window.Rocky.debug = function debugRocky() {
    console.log('API ->', API);
    console.log('account ->', account);
    console.log('serverAlive ->', serverAlive);
    console.log('local ->', getLocal(account));
    console.log('healthInterval ->', window._rocky_health_interval);
  };

  // chat append helpers (safe) with avatars + timestamps
  function createMsgElement({role, text, time}){
    const wrapper = document.createElement('div');
    wrapper.className = 'msg ' + (role === 'user' ? 'user' : 'assistant');

    const meta = document.createElement('div');
    meta.className = 'meta';

    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    avatar.textContent = role === 'user' ? 'YOU' : 'RS';
    avatar.style.background = role === 'user' ? 'linear-gradient(90deg, rgba(14,165,160,0.12), rgba(14,165,160,0.03))' : 'linear-gradient(90deg, rgba(255,176,32,0.08), rgba(255,176,32,0.02))';

    const who = document.createElement('strong');
    who.textContent = role === 'user' ? 'You' : 'Assistant';

    const ts = document.createElement('span');
    ts.style.marginLeft = '8px';
    ts.style.fontWeight = 600;
    ts.style.opacity = 0.8;
    ts.style.fontSize = '12px';
    ts.textContent = time || nowShort();

    meta.appendChild(avatar);
    meta.appendChild(who);
    meta.appendChild(ts);

    const content = document.createElement('div');
    content.style.marginTop = '8px';
    content.innerText = text || '';

    wrapper.appendChild(meta);
    wrapper.appendChild(content);
    return wrapper;
  }

  function appendUser(text) {
    const msgs = $('msgs');
    if (!msgs) return;
    const el = createMsgElement({role:'user', text, time: nowShort()});
    msgs.appendChild(el);
    msgs.scrollTop = msgs.scrollHeight;
  }

  function appendAssistant(text) {
    const msgs = $('msgs');
    if (!msgs) { console.log('Assistant:', text); return; }
    const el = createMsgElement({role:'assistant', text, time: nowShort()});
    msgs.appendChild(el);
    msgs.scrollTop = msgs.scrollHeight;
  }
  window.Rocky.appendAssistant = appendAssistant;

  function appendAssistantElement(el) {
    const msgs = $('msgs');
    if (!msgs) return;
    const container = document.createElement('div');
    container.className = 'msg assistant';
    container.appendChild(el);
    msgs.appendChild(container);
    msgs.scrollTop = msgs.scrollHeight;
  }

  // typing indicator
  function showTyping(on){
    const existing = document.getElementById('typingIndicator');
    if (on) {
      if (existing) return;
      const div = document.createElement('div');
      div.id = 'typingIndicator';
      div.className = 'typing';
      div.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div><div style="margin-left:8px">Assistant is typing</div>';
      const msgs = $('msgs'); if (!msgs) return; msgs.appendChild(div); msgs.scrollTop = msgs.scrollHeight;
    } else {
      if (existing) existing.remove();
    }
  }

  // local storage helpers
  function localStoreKey(acc) { return LOCAL_PREFIX + acc; }
  function getLocal(acc) {
    const raw = localStorage.getItem(localStoreKey(acc));
    return safeParseJSON(raw, { memories: {}, threads: {} });
  }
  function pushLocalMemory(acc, k, v) {
    const p = getLocal(acc);
    p.memories = p.memories || {};
    p.memories[k] = { value: v, timestamp: nowISO() };
    localStorage.setItem(localStoreKey(acc), JSON.stringify(p));
  }
  function pushLocalThread(acc, tid, msg) {
    const p = getLocal(acc);
    p.threads = p.threads || {};
    p.threads[tid] = p.threads[tid] || [];
    p.threads[tid].push(msg);
    localStorage.setItem(localStoreKey(acc), JSON.stringify(p));
  }
  window.Rocky.pushLocalMemory = pushLocalMemory;
  window.Rocky.pushLocalThread = pushLocalThread;

  // Memory CRUD & UI
  async function loadMemories(q = null) {
    if (!account) return;
    const memContainer = $('memList');
    if (memContainer) memContainer.textContent = 'Loading...';

    try {
      if (serverAlive && q) {
        const data = await fetchJSON(`${API}/search?q=${encodeURIComponent(q)}&limit=200`);
        const mems = (data && data.memories) || [];
        memEntries = mems.map(m => ({ key: m.key || m._id, value: m.value, raw: m }));
      } else if (serverAlive) {
        const j = await fetchJSON(`${API}/export/${encodeURIComponent(account)}`);
        const mems = (j && j.memories) || {};
        memEntries = Object.entries(mems).map(([k, v]) => ({
          key: k.split('::').pop(),
          value: (v && v.value !== undefined) ? v.value : v,
          raw: v
        }));
      } else {
        const local = getLocal(account);
        memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({
          key: k,
          value: (v && v.value !== undefined) ? v.value : v,
          raw: v
        }));
      }
    } catch (e) {
      console.warn('loadMemories catch', e);
      const local = getLocal(account);
      memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({
        key: k,
        value: (v && v.value !== undefined) ? v.value : v,
        raw: v
      }));
    }

    pageSize = parseInt((document.getElementById('pageSize') && document.getElementById('pageSize').value) || pageSize, 10);
    const total = memEntries.length;
    const pages = Math.max(1, Math.ceil(total / pageSize));
    if (currentPage > pages) currentPage = pages;
    const start = (currentPage - 1) * pageSize;
    const end = start + pageSize;
    renderMemList(memEntries.slice(start, end), total, currentPage, pages);
  }

  function renderMemList(items = [], total = 0, page = 1, pages = 1) {
    const container = $('memList');
    if (!container) return;
    container.innerHTML = '';
    const countEl = $('memCount');
    if (countEl) countEl.textContent = String(total);

    if (!items.length) {
      container.innerHTML = '<div class="small">No memories</div>';
      if ($('pageInfo')) $('pageInfo').textContent = `Page ${page}/${pages}`;
      return;
    }

    // bulk bar
    const bulkBar = document.createElement('div');
    bulkBar.style.marginBottom = '8px';
    const selectAllLabel = document.createElement('label');
    selectAllLabel.style.marginRight = '12px';
    const selectAllCheckbox = document.createElement('input');
    selectAllCheckbox.type = 'checkbox';
    selectAllCheckbox.id = 'selectAllMem';
    selectAllLabel.appendChild(selectAllCheckbox);
    selectAllLabel.appendChild(document.createTextNode(' Select All'));
    bulkBar.appendChild(selectAllLabel);

    const deleteSelectedBtn = document.createElement('button');
    deleteSelectedBtn.className = 'btn btn-ghost';
    deleteSelectedBtn.id = 'deleteSelected';
    deleteSelectedBtn.textContent = 'üóë Delete Selected';
    bulkBar.appendChild(deleteSelectedBtn);

    container.appendChild(bulkBar);

    items.forEach(it => {
      const div = document.createElement('div');
      div.className = 'memItem';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'memCheck';
      cb.dataset.key = it.key || '';

      const left = document.createElement('div');
      left.style.flex = '1';

      const keyDiv = document.createElement('div');
      keyDiv.className = 'memKey';
      keyDiv.textContent = it.key || '';

      const valDiv = document.createElement('div');
      valDiv.className = 'memVal';
      valDiv.textContent = (it.value !== undefined && it.value !== null) ? String(it.value) : '';

      left.appendChild(keyDiv);
      left.appendChild(valDiv);

      const controls = document.createElement('div');
      controls.className = 'controls';

      const view = document.createElement('button');
      view.className = 'btn btn-ghost';
      view.textContent = 'View';
      view.addEventListener('click', () => openViewer(it));

      const forget = document.createElement('button');
      forget.className = 'btn btn-ghost';
      forget.style.background = 'var(--danger)';
      forget.style.color = '#fff';
      forget.textContent = 'Forget';
      forget.addEventListener('click', () => forgetMem(it.key));

      controls.appendChild(view);
      controls.appendChild(forget);

      div.appendChild(cb);
      div.appendChild(left);
      div.appendChild(controls);

      container.appendChild(div);
    });

    selectAllCheckbox.addEventListener('change', () => {
      const checks = document.querySelectorAll('.memCheck');
      checks.forEach(cb => { cb.checked = selectAllCheckbox.checked; });
    });

    deleteSelectedBtn.addEventListener('click', async () => {
      const selected = Array.from(document.querySelectorAll('.memCheck:checked')).map(cb => cb.dataset.key);
      if (!selected.length) return alert('No memories selected');
      if (!confirm(`Delete ${selected.length} memories?`)) return;
      for (const key of selected) {
        // eslint-disable-next-line no-await-in-loop
        await forgetMem(key);
      }
      appendAssistant(`üóë Deleted ${selected.length} memories`);
      loadMemories();
    });

    if ($('pageInfo')) $('pageInfo').textContent = `Page ${page} / ${pages}`;
  }

  // Sync local -> server
    async function tryAutoSync(force = false) {
    if (!account) return; // nothing to sync

    const local = getLocal(account) || { memories: {}, threads: {} };
    const hasMem = local.memories && Object.keys(local.memories).length;
    const hasThreads = local.threads && Object.keys(local.threads).length;
    const has = (hasMem || hasThreads);

    if (!has && !force) return;
    try {
      const res = await fetch(`${API}/sync_local/${encodeURIComponent(account)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(local)
      });
      if (res.ok) {
        localStorage.removeItem(localStoreKey(account));
        appendAssistant('Local data synced to server');
        await loadMemories();
      } else {
        console.warn('sync failed', res.status);
      }
    } catch (e) {
      console.warn('sync failed', e);
    }
  }

  if ($('syncBtn')) $('syncBtn').addEventListener('click', () => tryAutoSync(true));

  // Search
  if ($('searchBtn')) {
    $('searchBtn').addEventListener('click', async () => {
      const q = ($('searchQ').value || '').trim(); currentPage = 1;
      if (!q) { loadMemories(); return; }
      if (serverAlive) { loadMemories(q); } else {
        const local = getLocal(account);
        memEntries = Object.entries(local.memories || {}).map(([k, v]) => ({ key: k, value: v.value || v, raw: v }))
          .filter(m => (m.key && m.key.toLowerCase().includes(q.toLowerCase())) || (String(m.value || '').toLowerCase().includes(q.toLowerCase())));
        renderMemList(memEntries.slice(0, pageSize), memEntries.length, 1, Math.max(1, Math.ceil(memEntries.length / pageSize)));
      }
    });
  }

  // Export
    async function triggerExport() {
    if (!account) return alert('Login first');
    try {
      const data = await fetchJSON(`${API}/export/${encodeURIComponent(account)}`);
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${String(account).replace(/[^a-z0-9@.\-]/gi, '_')}_export.json`;
      a.click();
    } catch (e) {
      console.warn('Export error', e);
      alert('Export failed ‚Äî server maybe offline or returned an unexpected response');
    }
  }

  if ($('exportBtn')) $('exportBtn').addEventListener('click', triggerExport);
  if ($('navExport')) $('navExport').addEventListener('click', triggerExport);

  // Chat flow
  if ($('messageBox')) {
    $('messageBox').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if ($('send')) $('send').click();
      }
    });
  }

  if ($('send')) {
    $('send').addEventListener('click', async () => {
      const text = ($('messageBox').value || '').trim();
      if (!text) return;
      if (!account) return alert('Login first');
      appendUser(text);
      if ($('messageBox')) $('messageBox').value = '';
      pushLocalThread(account, 'session', { role: 'user', content: text, timestamp: nowISO() });

      try {
                const use_llm = !!($('useLLM') && $('useLLM').checked);
        showTyping(true);

        // POST to agent; handle both JSON and text responses safely
        const res = await fetch(`${API}/agent/${encodeURIComponent(account)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text, use_llm })
        });

        // parse response robustly
        let j = null;
        try {
          const ct = (res.headers && res.headers.get ? res.headers.get('content-type') : '') || '';
          if (ct.includes('application/json')) {
            j = await res.json();
          } else {
            // fallback to plain text responses (wrap into reply)
            const txt = await res.text().catch(() => '');
            j = { reply: txt || '[no reply]' };
          }
        } catch (err) {
          console.warn('agent response parse error', err);
          j = { reply: '[invalid response]' };
        }

        const reply = (j && (j.reply || j.suggested_reply)) || '[no reply]';
        showTyping(false);
        appendAssistant(reply);
        pushLocalThread(account, 'session', { role: 'assistant', content: reply, timestamp: nowISO() });

        try { await loadMemories(); } catch(e) { console.warn('loadMemories after agent reply failed', e); }

      } catch (e) {
        showTyping(false);
        appendAssistant('[Server unreachable ‚Äî response saved locally]');
        pushLocalThread(account, 'session', { role: 'assistant', content: '[saved locally]', timestamp: nowISO() });
      }
    });
  }

  if ($('clearChat')) $('clearChat').addEventListener('click', () => { const m=$('msgs'); if(m) m.innerHTML=''; });

  if ($('refMemsBtn')) {
    $('refMemsBtn').addEventListener('click', () => {
      const slice = memEntries.slice(-3).map(m => `${m.key}: ${m.value}`).join('\n');
      if ($('messageBox')) {
        $('messageBox').value += '\n\n[Ref Memories]\n' + slice;
      }
    });
  }

  function openViewer(it) {
    const card = document.createElement('div');
    card.style.padding = '12px';
    card.style.borderRadius = '8px';
    card.style.background = '#fff';
    card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.06)';
    const strong = document.createElement('strong');
    strong.textContent = it.key || '';
    const pre = document.createElement('pre');
    pre.style.whiteSpace = 'pre-wrap';
    pre.style.marginTop = '8px';
    pre.textContent = (it.value !== undefined && it.value !== null) ? String(it.value) : '';
    card.appendChild(strong);
    card.appendChild(pre);
    appendAssistantElement(card);
  }

  // forget memory
  async function forgetMem(key) {
    if (!account) return alert('Login first');
    if (!confirm(`Forget memory "${key}"?`)) return;
    try {
      if (serverAlive) {
        await fetchJSON(`${API}/forget/${encodeURIComponent(account)}/${encodeURIComponent(key)}`, { method: 'DELETE' });
      } else {
        const p = getLocal(account);
        delete p.memories[key];
        localStorage.setItem(localStoreKey(account), JSON.stringify(p));
      }
      appendAssistant(`üóë Forgot "${key}"`);
      await loadMemories();
    } catch (e) {
      console.warn('forgetMem failed', e);
      alert('Forget failed');
    }
  }
  window.Rocky.forgetMem = forgetMem;
  window.Rocky.openViewer = openViewer;

  // Pagination
  if ($('prevPage')) $('prevPage').addEventListener('click', () => { if (currentPage>1) { currentPage--; loadMemories(); } });
  if ($('nextPage')) $('nextPage').addEventListener('click', () => { currentPage++; loadMemories(); });

  // Personality save/load & quick toggles
  async function setPersonalityFlag(flag, value) {
    if (!account) return;
    try {
      await fetchJSON(`${API}/remember`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ account, key: flag, value })
      });
    } catch (err) {
      pushLocalMemory(account, flag, value);
    }
  }

  async function pingAgent(msg, silent=false) {
    if (!account) return;
    try {
      await fetch(`${API}/agent/${encodeURIComponent(account)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: msg })
      });
      if (!silent) appendAssistant(`‚úÖ Agent synced: ${msg}`);
    } catch {
      if (!silent) appendAssistant('‚ö† Agent sync failed (offline)');
    }
  }

  // personality toggles
  const highestPersEl = $('highestPers');
  if (highestPersEl) highestPersEl.addEventListener('change', async e => {
    if (!account) return alert('Login first');
    const on = e.target.checked;
    await setPersonalityFlag("highestPers", on);
    await pingAgent(on ? 'bro personality highest' : 'bro personality reset');
    appendAssistant(on ? '‚ö° Highest Personality activated' : '‚ôª Highest Personality reset');
  });

  const immortalPersEl = $('immortalPers');
  if (immortalPersEl) immortalPersEl.addEventListener('change', async e => {
    if (!account) return alert('Login first');
    const on = e.target.checked;
    await setPersonalityFlag("immortalPers", on);
    await pingAgent(on ? 'bro immortal' : 'bro personality reset');
    appendAssistant(on ? '‚ôæÔ∏è Immortal Personality activated' : '‚ôª Immortal Personality reset');
  });

  const ghostPersEl = $('ghostPers');
  if (ghostPersEl) ghostPersEl.addEventListener('change', async e => {
    if (!account) return alert('Login first');
    const on = e.target.checked;
    await setPersonalityFlag("ghostPers", on);
    await pingAgent(on ? 'bro ghost' : 'bro personality reset');
    appendAssistant(on ? 'üëª Ghost Personality activated' : '‚ôª Ghost Personality reset');
  });

  // personality dropdown
  const sel = $('personalitySel');
  if (sel) {
    sel.addEventListener('change', async e => {
      const val = e.target.value;
      let cmd = '';
      if (val === 'highest') cmd = 'bro personality highest';
      if (val === 'immortal') cmd = 'bro immortal';
      if (val === 'ghost') cmd = 'bro ghost';
      if (val === 'default') cmd = 'bro personality reset';
      if (cmd) {
        await setPersonalityFlag('activePersonality', val);
        await pingAgent(cmd);
        appendAssistant(`üîÑ Personality switched to ${val.toUpperCase()}`);
      }
    });
  }

  // save/load personality UI
  if ($('savePers')) {
    $('savePers').onclick = async () => {
      if (!account) return alert('Login first');
      const pers = {
        tone: $('toneSel') ? $('toneSel').value : 'consistent',
        style: $('styleSel') ? $('styleSel').value : 'cofounder-high-energy',
        signature: $('sigInput') ? $('sigInput').value || '' : '',
      };
      try {
        await fetchJSON(`${API}/remember`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ account, key: '__personality__', value: pers })
        });
        appendAssistant('‚úÖ Stable personality saved');
      } catch (e) {
        pushLocalMemory(account, '__personality__', pers);
        appendAssistant('‚ö† Personality saved locally (server offline)');
      }
    };
  }

  if ($('loadPers')) {
    $('loadPers').addEventListener('click', async () => {
      if (!account) return alert('Login first');
      try {
        const res = await fetch(`${API}/recall/${encodeURIComponent(account)}/__personality__`);
        if (res.ok) {
          const j = await res.json();
          const p = j.value || j;
          if ($('toneSel')) $('toneSel').value = p.tone || 'consistent';
          if ($('styleSel')) $('styleSel').value = p.style || 'cofounder-high-energy';
          if ($('sigInput')) $('sigInput').value = p.signature || 'üíéüî•';
          appendAssistant('Personality loaded from server');
          return;
        }
      } catch (e) {}
      const local = getLocal(account);
      const p = (local.memories && local.memories['__personality__'] && local.memories['__personality__'].value) || null;
      if (p) {
        if ($('toneSel')) $('toneSel').value = p.tone || 'consistent';
        if ($('styleSel')) $('styleSel').value = p.style || 'cofounder-high-energy';
        if ($('sigInput')) $('sigInput').value = p.signature || 'üíéüî•';
        appendAssistant('Loaded personality locally');
      } else appendAssistant('No saved personality found');
    });
  }

  // system prompt save/clear
  if ($('savePrompt')) $('savePrompt').addEventListener('click', () => {
    appendAssistant('System prompt saved (applies when LLM enabled)');
  });
  if ($('clearPrompt')) $('clearPrompt').addEventListener('click', () => {
    if ($('systemPrompt')) $('systemPrompt').value = '';
    appendAssistant('System prompt cleared');
  });

  // login/logout
  if ($('login')) {
    $('login').addEventListener('click', () => {
      const email = ($('email') && $('email').value || '').trim();
      if (!email) return alert('Enter an email to login');
      account = email;
      localStorage.setItem('rocky_account', account);
      showLoginUI();
      appendAssistant(`‚úÖ Logged in as ${account}`);
      setTimeout(() => loadMemories(), 150);
    });
  }
  if ($('logout')) {
    $('logout').addEventListener('click', () => {
      localStorage.removeItem('rocky_account');
      account = '';
      showLoginUI();
      appendAssistant('üîí Logged out');
    });
  }

  // add quick memory
  if ($('addQuick')) {
    $('addQuick').addEventListener('click', async () => {
      if (!account) return alert('Login first');
      const k = ($('addKey').value || '').trim();
      const v = ($('addVal').value || '').trim();
      if (!k) return alert('Provide a key');
      try {
        if (serverAlive) {
          await fetchJSON(`${API}/remember`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account, key: k, value: v })
          });
          appendAssistant(`‚úÖ Saved memory "${k}"`);
        } else {
          pushLocalMemory(account, k, v);
          appendAssistant(`‚úÖ Saved memory "${k}" locally`);
        }
        $('addKey').value = '';
        $('addVal').value = '';
        await loadMemories();
      } catch (e) {
        console.warn('addQuick failed', e);
        appendAssistant('‚ö† Save failed');
      }
    });
  }
  
  // bulk add handler
  if ($('bulkAddBtn')) {
    $('bulkAddBtn').addEventListener('click', async () => {
      if (!account) return alert('Login first');
      const text = ($('bulkMemories').value || '').trim();
      if (!text) return alert('Provide bulk data');
      let mems = [];
      try {
        if (text.startsWith('{')) {
          const obj = JSON.parse(text);
          mems = Object.entries(obj);
        } else {
          mems = text.split('\n').map(l => l.split(':')).filter(a => a.length >= 2);
        }
      } catch (e) {
        return alert('Invalid format ‚Äî use JSON or key:value per line');
      }
      let added = 0;
      for (const [k, v] of mems) {
        try {
          if (serverAlive) {
            // eslint-disable-next-line no-await-in-loop
            await fetchJSON(`${API}/remember`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ account, key: k.trim(), value: v.toString().trim() })
            });
          } else {
            pushLocalMemory(account, k.trim(), v.toString().trim());
          }
          added++;
        } catch (err) {
          pushLocalMemory(account, k.trim(), v.toString().trim());
        }
      }
      $('bulkMemories').value = '';
      appendAssistant(`‚úÖ Added ${added} memories`);
      await loadMemories();
    });
  }

  // initial load if logged in
  if (account) {
    setTimeout(() => { loadMemories(); }, 200);
  }

    // ----- Navigation (Chat / Memories / Settings) -----
  (function wireNavigation() {
   function showPanel(name){
    const chat = $('chatPanel');
    const mem  = $('memoryPanel');
    const set  = $('settingsPanel');
    const navChat = $('navChat');
    const navMemory = $('navMemory');
    const navSettings = $('navSettings');

    if(chat) chat.classList.toggle('hidden', name !== 'chat');
    if(mem)  mem.classList.toggle('hidden', name !== 'memories');
    if(set)  set.classList.toggle('hidden', name !== 'settings');

    if(navChat)    navChat.classList.toggle('active', name === 'chat');
    if(navMemory)  navMemory.classList.toggle('active', name === 'memories');
    if(navSettings)navSettings.classList.toggle('active', name === 'settings');

    if(navChat)    navChat.setAttribute('aria-pressed', name === 'chat');
    if(navMemory)  navMemory.setAttribute('aria-pressed', name === 'memories');
    if(navSettings)navSettings.setAttribute('aria-pressed', name === 'settings');

    // If opening memories, ensure data is fresh
    if (name === 'memories') {
        try { loadMemories(); } catch(e){ console.warn('loadMemories error', e); }
    }
  }

  const navChatBtn = $('navChat'); if (navChatBtn) navChatBtn.addEventListener('click', () => showPanel('chat'));
  const navMemBtn  = $('navMemory'); if (navMemBtn)  navMemBtn.addEventListener('click', () => showPanel('memories'));
  const navSetBtn  = $('navSettings'); if (navSetBtn) navSetBtn.addEventListener('click', () => showPanel('settings'));

  // keyboard shortcuts (1 = Chat, 2 = Memories, 3 = Settings)
  window.addEventListener('keydown', (e) => {
      if (e.altKey || e.ctrlKey || e.metaKey) return;
      if (e.key === '1') showPanel('chat');
      if (e.key === '2') showPanel('memories');
      if (e.key === '3') showPanel('settings');
  });

  // default view
  showPanel('chat');
  })();

})();
</script>

</body>
</html>



